'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var mobxStateTree = require('mobx-state-tree');

var atomic = mobxStateTree.createActionTrackingMiddleware2({
    filter: function (call) {
        // only call the methods above for actions that were not being recorded,
        // but do not call them for child acions (which inherit a copy of the env)
        if (call.env) {
            // already recording
            return false;
        }
        return true;
    },
    onStart: function (call) {
        var recorder = mobxStateTree.recordPatches(call.tree, function (_patch, _inversePatch, actionContext) {
            // only record patches that were generated by this action or children of this action
            return !!actionContext && mobxStateTree.isActionContextThisOrChildOf(actionContext, call.id);
        });
        recorder.resume();
        call.env = {
            recorder: recorder
        };
    },
    onFinish: function (call, error) {
        var recorder = call.env.recorder;
        call.env = undefined;
        recorder.stop();
        if (error !== undefined) {
            recorder.undo();
        }
    }
});

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

/**
 * Creates a tiny proxy around a MST tree that conforms to the redux store api.
 * This makes it possible to use MST inside a redux application.
 *
 * See the [redux-todomvc example](https://github.com/mobxjs/mobx-state-tree/blob/e9e804c8c43e1edde4aabbd52675544e2b3a905b/examples/redux-todomvc/src/index.js#L20) for more details.
 *
 * @export
 * @param {*} model
 * @param {...MiddleWare[]} middlewares
 * @returns {IReduxStore}
 */
var asReduxStore = function (model) {
    var middlewares = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        middlewares[_i - 1] = arguments[_i];
    }
    if (!mobxStateTree.isStateTreeNode(model))
        throw new Error("Expected model object");
    var store = {
        getState: function () { return mobxStateTree.getSnapshot(model); },
        dispatch: function (action) {
            runMiddleWare(action, runners.slice(), function (newAction) {
                return mobxStateTree.applyAction(model, reduxActionToAction(newAction));
            });
        },
        subscribe: function (listener) { return mobxStateTree.onSnapshot(model, listener); }
    };
    var runners = middlewares.map(function (mw) { return mw(store); });
    return store;
};
function reduxActionToAction(action) {
    var actionArgs = Object.assign({}, action);
    delete actionArgs.type;
    return {
        name: action.type,
        args: [actionArgs]
    };
}
function runMiddleWare(action, runners, next) {
    function n(retVal) {
        var f = runners.shift();
        if (f)
            f(n)(retVal);
        else
            next(retVal);
    }
    n(action);
}
function getActionContextNameAndTypePath(actionContext, logArgsNearName) {
    var name = actionContext.name;
    var targetTypePath = actionContext.targetTypePath;
    if (logArgsNearName) {
        var args = actionContext.callArgs.map(function (a) { return JSON.stringify(a); }).join(", ");
        if (args.length > 64) {
            args = args.slice(0, 64) + "...";
        }
        name += "(" + args + ")";
    }
    if (actionContext.runningAsync) {
        name += " (" + (actionContext.step !== undefined ? actionContext.step : "?") + ")";
    }
    if (actionContext.errored) {
        name += " -error thrown-";
    }
    if (actionContext.parent) {
        var ret = getActionContextNameAndTypePath(actionContext.parent, logArgsNearName);
        if (ret) {
            name = ret.name + " >>> " + name;
            targetTypePath = ret.targetTypePath + " >>> " + targetTypePath;
        }
    }
    return {
        name: name,
        targetTypePath: targetTypePath
    };
}
function getTypeName(node) {
    return mobxStateTree.getType(node).name || "(UnnamedType)";
}
function getTargetTypePath(node) {
    var current = node;
    var names = [];
    while (current) {
        names.unshift(getTypeName(current));
        current = mobxStateTree.hasParent(current) ? mobxStateTree.getParent(current) : undefined;
    }
    return names;
}
/**
 * Connects a MST tree to the Redux devtools.
 * See this [example](https://github.com/mobxjs/mobx-state-tree/blob/e9e804c8c43e1edde4aabbd52675544e2b3a905b/examples/redux-todomvc/src/index.js#L21)
 * for a setup example.
 *
 * @export
 * @param {*} remoteDevDep
 * @param {IAnyStateTreeNode} model
 * @param {{
 *         logIdempotentActionSteps?: boolean
 *         logChildActions?: boolean
 *         logArgsNearName?: boolean
 *     }} [options]
 */
function connectReduxDevtools(remoteDevDep, model, options) {
    var opts = __assign({ logIdempotentActionSteps: true, logChildActions: false, logArgsNearName: true }, options);
    var handlingMonitorAction = 0;
    // Connect to the monitor
    var remotedev = remoteDevDep.connectViaExtension({
        name: mobxStateTree.getType(model).name
    });
    // Subscribe to change state (if need more than just logging)
    remotedev.subscribe(function (message) {
        if (message.type === "DISPATCH") {
            handleMonitorActions(remotedev, model, message);
        }
    });
    var initialState = mobxStateTree.getSnapshot(model);
    remotedev.init(initialState);
    var actionContexts = new Map();
    var changesMadeSetter = undefined;
    if (!opts.logIdempotentActionSteps) {
        mobxStateTree.onPatch(model, function () {
            if (!handlingMonitorAction && changesMadeSetter) {
                changesMadeSetter();
            }
        });
    }
    mobxStateTree.addMiddleware(model, actionMiddleware, false);
    function actionMiddleware(call, next) {
        if (handlingMonitorAction) {
            next(call);
            return;
        }
        var context;
        // find the context of the parent action (if any)
        for (var i = call.allParentIds.length - 1; i >= 0; i--) {
            var parentId = call.allParentIds[i];
            var foundContext = actionContexts.get(parentId);
            if (foundContext) {
                context = foundContext;
                break;
            }
        }
        // if it is an action we need to create a new action context
        // and also if there's no context (e.g. the middleware was connected in the middle of an action with a flow)
        if (call.type === "action" || !context) {
            var targetTypePath = getTargetTypePath(call.context).join("/");
            var parentContext = context;
            var path = call.context ? "root" + mobxStateTree.getPath(call.context) : "*unknown*";
            context = {
                // use a space rather than a dot so that the redux devtools move the actions to the next line if there's not enough space
                name: "[" + path + "] " + (call.name || "*unknownAction*"),
                targetTypePath: targetTypePath,
                id: call.id,
                runningAsync: false,
                errored: false,
                errorReported: false,
                step: call.type === "action" ? 0 : undefined,
                callArgs: [],
                changesMadeSetter: undefined
            };
            if (call.type === "action") {
                if (call.args) {
                    context.callArgs = __spread(call.args);
                }
                // subaction, assign the parent action context
                if (call.parentId) {
                    context.parent = parentContext;
                }
                actionContexts.set(call.id, context);
            }
        }
        var changesMade = false;
        context.changesMadeSetter = function () {
            changesMade = true;
        };
        var oldChangesMadeSetter = changesMadeSetter;
        changesMadeSetter = context.changesMadeSetter;
        // capture any errors and rethrow them later (after it is logged)
        var errorThrown;
        try {
            next(call);
        }
        catch (e) {
            errorThrown = e;
            context.errored = true;
        }
        changesMadeSetter = oldChangesMadeSetter;
        context.changesMadeSetter = undefined;
        var changedTheModel = opts.logIdempotentActionSteps ? true : changesMade;
        switch (call.type) {
            case "flow_spawn":
            case "flow_resume":
            case "flow_resume_error": // not errored since the promise error might be caught
                // when this events come we can be sure that this action is being run async, as well as its parent actions
                context.runningAsync = true;
                var parent = context.parent;
                while (parent) {
                    parent.runningAsync = true;
                    parent = parent.parent;
                }
                break;
            case "flow_throw":
                context.errored = true;
                break;
        }
        // only log if:
        // - it is a sync (never run async code) action
        // - a flow_resume
        // - a flow_throw that wasn't reported as an error before
        // we don't include other kinds since flow_spawn never contain state changes and flow_resume_error might be caught by and handled the parent
        var syncAction = call.type === "action" && !context.runningAsync;
        var log = syncAction ||
            call.type === "flow_resume" ||
            (call.type === "flow_throw" && !context.errorReported);
        // do not log child actions if asked not to, but only for sync actions
        if (!opts.logChildActions && context.parent && !context.runningAsync) {
            log = false;
            // give the child action changes to the parent action
            if (changesMade && context.parent.changesMadeSetter) {
                context.parent.changesMadeSetter();
            }
        }
        if (log) {
            var logStep = function (logContext) {
                var sn = mobxStateTree.getSnapshot(model);
                var names = getActionContextNameAndTypePath(logContext, opts.logArgsNearName);
                var copy = {
                    type: names.name,
                    targetTypePath: names.targetTypePath,
                    args: logContext.callArgs
                };
                remotedev.send(copy, sn);
                // we do it over the original context, not the log context, since the original context might throw but the original context might not
                if (context.errored) {
                    context.errorReported = true;
                }
                // increase the step for logging purposes, as well as any parent steps (since child steps count as a parent step)
                if (context.step !== undefined) {
                    context.step++;
                }
                var parent = context.parent;
                while (parent) {
                    if (parent.step !== undefined) {
                        parent.step++;
                    }
                    parent = parent.parent;
                }
            };
            // if it is an async subaction we need to log it since it made a change, but we will log it as if it were the root
            var logAsRoot = context.parent && !opts.logChildActions;
            if (changedTheModel) {
                var logContext = context;
                if (logAsRoot) {
                    while (logContext.parent) {
                        logContext = logContext.parent;
                    }
                }
                logStep(logContext);
            }
            else if (!logAsRoot && context.errored && !context.errorReported) {
                logStep(context);
            }
        }
        // once the action is totally finished remove it from the context list to avoid mem leaks
        if (call.type === "flow_return" || call.type === "flow_throw" || !context.runningAsync) {
            actionContexts.delete(context.id);
        }
        // rethrow previously captured excepton if needed
        if (errorThrown) {
            throw errorThrown;
        }
    }
    function handleMonitorActions(remotedev2, model2, message) {
        try {
            handlingMonitorAction++;
            switch (message.payload.type) {
                case "RESET":
                    mobxStateTree.applySnapshot(model2, initialState);
                    return remotedev2.init(initialState);
                case "COMMIT":
                    return remotedev2.init(mobxStateTree.getSnapshot(model2));
                case "ROLLBACK":
                    return remotedev2.init(remoteDevDep.extractState(message));
                case "JUMP_TO_STATE":
                case "JUMP_TO_ACTION":
                    mobxStateTree.applySnapshot(model2, remoteDevDep.extractState(message));
                    return;
                case "IMPORT_STATE":
                    var nextLiftedState = message.payload.nextLiftedState;
                    var computedStates = nextLiftedState.computedStates;
                    mobxStateTree.applySnapshot(model2, computedStates[computedStates.length - 1].state);
                    remotedev2.send(null, nextLiftedState);
                    return;
                default:
            }
        }
        finally {
            handlingMonitorAction--;
        }
    }
}

function simpleActionLogger(call, next) {
    if (call.type === "action" && call.parentId === 0)
        console.log("[MST] " + mobxStateTree.getPath(call.context) + "/" + call.name);
    return next(call);
}

function actionLogger(call, next) {
    var skip = (call.type === "action" && call.parentId !== 0) ||
        call.type === "flow_resume" ||
        call.type === "flow_resume_error";
    if (!skip)
        console.log("[MST] #" + call.rootId + " " + call.type + " - " + mobxStateTree.getPath(call.context) + "/" + call.name);
    next(call);
}

var TimeTraveller = mobxStateTree.types
    .model("TimeTraveller", {
    history: mobxStateTree.types.array(mobxStateTree.types.frozen()),
    undoIdx: -1,
    targetPath: ""
})
    .views(function (self) { return ({
    get canUndo() {
        return self.undoIdx > 0;
    },
    get canRedo() {
        return self.undoIdx < self.history.length - 1;
    }
}); })
    .actions(function (self) {
    var targetStore;
    var snapshotDisposer;
    var skipNextUndoState = false;
    return {
        addUndoState: function (todos) {
            if (skipNextUndoState) {
                // skip recording if this state was caused by undo / redo
                skipNextUndoState = false;
                return;
            }
            self.history.splice(self.undoIdx + 1);
            self.history.push(todos);
            self.undoIdx = self.history.length - 1;
        },
        afterCreate: function () {
            var _this = this;
            targetStore = self.targetPath
                ? mobxStateTree.resolvePath(self, self.targetPath)
                : mobxStateTree.getEnv(self).targetStore;
            if (!targetStore)
                throw new Error("Failed to find target store for TimeTraveller. Please provide `targetPath` property, or a `targetStore` in the environment");
            // TODO: check if targetStore doesn't contain self
            // if (contains(targetStore, self)) throw new Error("TimeTraveller shouldn't be recording itself. Please specify a sibling as taret, not some parent")
            // start listening to changes
            snapshotDisposer = mobxStateTree.onSnapshot(targetStore, function (snapshot) {
                return _this.addUndoState(snapshot);
            });
            // record an initial state if no known
            if (self.history.length === 0) {
                this.addUndoState(mobxStateTree.getSnapshot(targetStore));
            }
        },
        beforeDestroy: function () {
            snapshotDisposer();
        },
        undo: function () {
            self.undoIdx--;
            skipNextUndoState = true;
            mobxStateTree.applySnapshot(targetStore, self.history[self.undoIdx]);
        },
        redo: function () {
            self.undoIdx++;
            skipNextUndoState = true;
            mobxStateTree.applySnapshot(targetStore, self.history[self.undoIdx]);
        }
    };
});

var Entry = mobxStateTree.types.model("UndoManagerEntry", {
    patches: mobxStateTree.types.frozen(),
    inversePatches: mobxStateTree.types.frozen()
});
var UndoManager = mobxStateTree.types
    .model("UndoManager", {
    history: mobxStateTree.types.array(Entry),
    undoIdx: 0
})
    .views(function (self) { return ({
    get undoLevels() {
        return self.undoIdx;
    },
    get redoLevels() {
        return self.history.length - self.undoIdx;
    },
    get canUndo() {
        return this.undoLevels > 0;
    },
    get canRedo() {
        return this.redoLevels > 0;
    }
}); })
    .actions(function (self) {
    var targetStore;
    var recordingDisabled = 0;
    var groupRecorders = [];
    var undoRedoMiddleware = mobxStateTree.createActionTrackingMiddleware2({
        filter: function (call) {
            if (call.env) {
                // already recording
                return false;
            }
            if (call.context === self) {
                // also skip actions over self
                return false;
            }
            return true;
        },
        onStart: function (call) {
            var recorder = mobxStateTree.recordPatches(call.tree, function (_patch, _inversePatch, actionContext) {
                if (recordingDisabled) {
                    return false;
                }
                // only record patches that were generated by this action or children of this action
                return (!!actionContext && mobxStateTree.isActionContextThisOrChildOf(actionContext, call.id));
            });
            recorder.resume();
            call.env = {
                recorder: recorder
            };
        },
        onFinish: function (call, error) {
            var recorder = call.env.recorder;
            call.env = undefined;
            recorder.stop();
            if (error === undefined) {
                if (groupRecorders.length > 0) {
                    var groupRecorder = groupRecorders[groupRecorders.length - 1];
                    groupRecorder.patches = groupRecorder.patches.concat(recorder.patches);
                    groupRecorder.inversePatches = groupRecorder.inversePatches.concat(recorder.inversePatches);
                }
                else {
                    self.addUndoState(recorder);
                }
            }
            else {
                recorder.undo();
            }
        }
    });
    var skipRecording = function (fn) {
        recordingDisabled++;
        try {
            return fn();
        }
        finally {
            recordingDisabled--;
        }
    };
    return {
        addUndoState: function (recorder) {
            this.withoutUndo(function () {
                if (recorder.patches.length === 0) {
                    // skip recording if patches is empty
                    return;
                }
                self.history.splice(self.undoIdx);
                self.history.push({
                    patches: recorder.patches,
                    inversePatches: recorder.inversePatches
                });
                var maxLength = mobxStateTree.getEnv(self).maxHistoryLength || Infinity;
                self.history.splice(0, self.history.length - maxLength);
                self.undoIdx = self.history.length;
            });
        },
        afterCreate: function () {
            var selfRoot = mobxStateTree.getRoot(self);
            targetStore = mobxStateTree.getEnv(self).targetStore || selfRoot;
            if (targetStore === self) {
                throw new Error("UndoManager should be created as part of a tree, or with `targetStore` in it's environment");
            }
            mobxStateTree.addDisposer(self, mobxStateTree.addMiddleware(targetStore, undoRedoMiddleware, false));
        },
        undo: mobxStateTree.decorate(atomic, function () {
            skipRecording(function () {
                if (!self.canUndo) {
                    throw new Error("undo not possible, nothing to undo");
                }
                mobxStateTree.applyPatch(mobxStateTree.getRoot(targetStore), 
                // n.b: reverse patches back to forth
                self.history[self.undoIdx - 1].inversePatches.slice().reverse());
                self.undoIdx--;
            });
        }),
        redo: mobxStateTree.decorate(atomic, function () {
            skipRecording(function () {
                if (!self.canRedo) {
                    throw new Error("redo not possible, nothing to redo");
                }
                mobxStateTree.applyPatch(mobxStateTree.getRoot(targetStore), self.history[self.undoIdx].patches);
                self.undoIdx++;
            });
        }),
        withoutUndo: function (fn) {
            return skipRecording(fn);
        },
        withoutUndoFlow: function (generatorFn) {
            return mobxStateTree.flow(function __withoutUndoFlow__() {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            recordingDisabled++;
                            _a.label = 1;
                        case 1:
                            _a.trys.push([1, , 3, 4]);
                            return [5 /*yield**/, __values(generatorFn())];
                        case 2: return [2 /*return*/, _a.sent()];
                        case 3:
                            recordingDisabled--;
                            return [7 /*endfinally*/];
                        case 4: return [2 /*return*/];
                    }
                });
            });
        },
        startGroup: function (fn) {
            if (groupRecorders.length >= 1) {
                throw new Error("a previous startGroup is still running, did you forget to call stopGroup?");
            }
            groupRecorders.push({
                patches: [],
                inversePatches: []
            });
            return fn();
        },
        stopGroup: function () {
            var groupRecorder = groupRecorders.pop();
            if (!groupRecorder) {
                throw new Error("each call to stopGroup requires a previous call to startGroup, did you forget to call startGroup?");
            }
            this.addUndoState(groupRecorder);
        },
        clear: mobxStateTree.decorate(atomic, function () {
            skipRecording(function () {
                self.history.clear();
                self.undoIdx = 0;
            });
        }),
        clearUndo: mobxStateTree.decorate(atomic, function () {
            skipRecording(function () {
                self.history.splice(0, self.undoLevels);
                self.undoIdx = 0;
            });
        }),
        clearRedo: mobxStateTree.decorate(atomic, function () {
            skipRecording(function () {
                self.history.splice(self.undoIdx, self.redoLevels);
            });
        })
    };
});

exports.TimeTraveller = TimeTraveller;
exports.UndoManager = UndoManager;
exports.actionLogger = actionLogger;
exports.asReduxStore = asReduxStore;
exports.atomic = atomic;
exports.connectReduxDevtools = connectReduxDevtools;
exports.simpleActionLogger = simpleActionLogger;
