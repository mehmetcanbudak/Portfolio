import { IJsonPatch, IPatchRecorder } from "mobx-state-tree";
declare const UndoManager: import("mobx-state-tree").IModelType<{
    history: import("mobx-state-tree").IArrayType<import("mobx-state-tree").IModelType<{
        patches: import("mobx-state-tree").IType<readonly IJsonPatch[], readonly IJsonPatch[], readonly IJsonPatch[]>;
        inversePatches: import("mobx-state-tree").IType<readonly IJsonPatch[], readonly IJsonPatch[], readonly IJsonPatch[]>;
    }, {}, import("mobx-state-tree")._NotCustomized, import("mobx-state-tree")._NotCustomized>>;
    undoIdx: import("mobx-state-tree").IType<number | undefined, number, number>;
}, {
    readonly undoLevels: number;
    readonly redoLevels: number;
    readonly canUndo: boolean;
    readonly canRedo: boolean;
} & {
    addUndoState(recorder: Pick<IPatchRecorder, "patches" | "inversePatches">): void;
    afterCreate(): void;
    undo: () => void;
    redo: () => void;
    withoutUndo<T>(fn: () => T): T;
    withoutUndoFlow(generatorFn: () => any): () => Promise<any>;
    startGroup<T_1>(fn: () => T_1): T_1;
    stopGroup(): void;
    clear: () => void;
    clearUndo: () => void;
    clearRedo: () => void;
}, import("mobx-state-tree")._NotCustomized, import("mobx-state-tree")._NotCustomized>;
export default UndoManager;
